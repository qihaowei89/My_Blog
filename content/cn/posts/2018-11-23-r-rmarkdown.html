---
title: "Shiny Server 专业V1.5.10管理员指南"
author: 
date: 2018-11-23
categories: ["R"]
tags: ["R Markdown", "shiny", "shiny-server"]
---



<div id="shiny-server-专业v1.5.10管理员指南" class="section level1">
<h1>Shiny Server 专业V1.5.10管理员指南</h1>
<p>Shiny Server使用户可以在互联网上搭建和管理Shiny app。</p>
<div id="系统需求" class="section level2">
<h2>1.1 系统需求：</h2>
<p>RedHat or Ubuntu</p>
</div>
<div id="安装" class="section level2">
<h2>1.2 安装:</h2>
<div id="ubuntu" class="section level3">
<h3>1.2.1 Ubuntu</h3>
<p>安装 R</p>
<pre><code>sudo apt-get install r-base
</code></pre>
<p>安装 shiny-server</p>
<pre><code>sudo apt-get install gdebi-core
sudo gdebi shiny-server-&lt;version&gt;.deb</code></pre>
</div>
<div id="redhat" class="section level3">
<h3>1.2.2 RedHat</h3>
<pre><code>## R

sudo yum install R 

## shiny-server 

sudo yum install --nogpgcheck shiny-server-&lt;version&gt;.rpm
</code></pre>
</div>
<div id="install-shiny" class="section level3">
<h3>1.2.3 Install Shiny</h3>
<p>安装Shiny-server之前需要在系统中安装shiny包，需要使用<code>sudo</code>在管理员权限下安装。</p>
<pre><code>
### Install The Shiny Package
sudo su - -c &quot;R -e \&quot;install.packages(&#39;shiny&#39;,repos=&#39;https://cran.rstudio.com/&#39;)\&quot;&quot;
</code></pre>
</div>
<div id="r的安装路径" class="section level3">
<h3>1.2.4 R的安装路径</h3>
<p>可以通过修改shiny-server的配置文件 <code>/etc/init.d/shiny-server</code> or <code>/etc/init/shiny-server.conf</code>来指定R的安装路径，或者通过将R安装路径添加到系统的环境变量<code>PATH</code>中，或设定一个名为 <strong>R</strong> 的环境变量指定可执行的文件路径,将<code>env R=/usr/local/bin/R-3-0-1</code>或着<code>export R=/usr/local/bin/R-3-0-1</code> 添加到init.d文件中。</p>
</div>
</div>
<div id="服务stopping-的-starting" class="section level2">
<h2>1.3 服务Stopping 的 Starting</h2>
<div id="systemd-redhat-ubuntu-15.04-sles-12" class="section level3">
<h3>1.3.1 systemd (RedHat , Ubuntu 15.04+, SLES 12+)</h3>
<p>systemd 设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<p>Shiny Server 安装包会自动安装一个名为shiny-server的systemd的服务，在机器启动或者关闭的时候自动开启或者停止shiny-server程序。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">systemd</a>常用命令：</p>
<pre><code># 重启系统
sudo systemctl reboot

# 关闭系统，切断电源
sudo systemctl poweroff

# CPU停止工作
sudo systemctl halt

# 暂停系统
sudo systemctl suspend

# 让系统进入冬眠状态
sudo systemctl hibernate

# 让系统进入交互式休眠状态
sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
sudo systemctl rescue</code></pre>
<p>可以手动开启或在停止服务：</p>
<pre><code># 开启服务
sudo systemctl start shiny-server
# 停止服务
sudo systemctl stop shiny-server

# 重启服务，停止所有正在运行的Shiny程序，断开所有打开的连接，并重新初始化服务器。
sudo systemctl restart shiny-server  


# 如果希望重新加载配置，但保持服务器和所有Shiny进程不中断，可以使用systemctl命令发送SIGHUP信号：
sudo systemctl kill -s HUP --kill-who=main shiny-server


# 查看shiny-server服务的状态
sudo systemctl status shiny-server   

# 使用`enable/disable`命令控制shiny server 是否在系统启动时自动运行
sudo systemctl enable shiny-server 

sudo systemctl disable shiny-server
</code></pre>
</div>
<div id="upstartubuntu-redhat" class="section level3">
<h3>1.3.2 Upstart(Ubuntu, RedHat)</h3>
<p>Upstart是一个用于自动启动、停止和管理服务的系统。安装程序将自动将Upstart脚本部署到/etc/init/shiny-server.conf。此脚本将在系统激活网络时初始化shiny-server，并在系统关闭时停止。如果进程意外终止，则UpScript脚本还将确保<strong>shiny-server</strong>重启。但是，如果存在一个始终阻止Shiny Server启动的问题（比如一个错误的配置文件），Upstart将在尝试大约5次失败后放弃重新启动服务。</p>
<pre><code># start
sudo start shiny-server 
# stop
sudo stop shiny-server

# restart 建议通过 stop----&gt;start 方式重启服务，因为restart会 缓存一些可能会导致服务器不检测最近发生的更改的数据。


sudo stop shiny-server
sudo start shint-server 

上面的命令会关闭所有运行的Shiny 进程，断开所有开放的连接，并重新初始化服务。值得注意的是restart不会重新读取配置文件 /etc/init/shiny-server.conf.

# 重新载入配置文件，但是不中断服务和所有Shiny进程
sudo reload shiny-server

# 查看shiny-server运行状态或者相关进程ID
statu shiny-server</code></pre>
</div>
</div>
<div id="服务管理" class="section level2">
<h2>2 服务管理</h2>
<div id="默认配置" class="section level3">
<h3>2.1 默认配置</h3>
<p>有关每个可用设置和参数的详细信息可在<a href="http://docs.rstudio.com/shiny-server/#appendix">附录</a>中找到，
本节讨论默认在/etc/shiny-server/shiny-server.conf下的配置文件,shiny-server的默认配置文件如下：</p>
<pre><code># Define the user we should use when spawning R Shiny processes
run_as shiny;

# Define a top-level server which will listen on a port
server {
  # Instruct this server to listen on port 3838
  listen 3838;

  # Define the location available at the base URL
  location / {
    #### PRO ONLY ####
    # Only up tp 20 connections per Shiny process and at most 3 Shiny processes
    # per application. Proactively spawn a new process when our processes reach 
    # 90% capacity.
    utilization_scheduler 20 .9 3;
    #### END PRO ONLY ####

    # Run this location in &#39;site_dir&#39; mode, which hosts the entire directory
    # tree at &#39;/srv/shiny-server&#39;
    site_dir /srv/shiny-server;
    
    # Define where we should put the log files for this location
    log_dir /var/log/shiny-server;
    
    # Should we list the contents of a (non-Shiny-App) directory when the user 
    # visits the corresponding URL?
    directory_index on;
  }
}


# Setup a flat-file authentication system. {.pro}
auth_passwd_file /etc/shiny-server/passwd;

# Define a default admin interface to be run on port 4151. {.pro}
admin 4151 {
  # Only permit the user named `admin` to access the admin interface.
  required_user admin;
}
</code></pre>
<p>可以配置不同端口或主机名上托管多个服务器。每个<strong>服务器</strong>都可以有能够shiny-server的应用程序和静态资源的<strong>位置</strong>。单个应用程序还可以重写应用于它们父<strong>位置</strong>的设置。这些概念在<a href="http://docs.rstudio.com/shiny-server/#server-hierarchy">服务器层次结构</a>部分进一步详细说明,默认配置文件将创建一个监听端口为3838的单个服务，服务在根URL(/)下的/srv/shiny-server文件夹中的任何服务<br />
自定义服务器配置文件：/etc/shiny-server/shiny-server.conf</p>
</div>
</div>
<div id="服务的配置层级关系" class="section level2">
<h2>2.2 服务的配置层级关系</h2>
<div id="server" class="section level3">
<h3>2.2.1 Server</h3>
<pre><code>server {
  # listen  port
  listen 80;
  
  # accept  hostname 
  server_name server1.com;
}</code></pre>
</div>
<div id="location" class="section level3">
<h3>2.2.2 Location</h3>
<pre><code>server {
  ...
  
  # 定义位置在 &#39;/specialApp&#39;下的单个shiny程序
    location /specicalApp {
      # 运行app_dir模式，托管 /srv/shiny-server/myApp 下的单个Shiny应用程序
      app_dir /srv/shiny-server/myApp
  }
 
 
 # 定义位置在 &#39;/otherApps&#39;下的全部shiny程序
  location /otherApps {
      # 运行site_dir模式， 托管 /srv/shiny-server/apps 下的多个Shiny应用程序
      site_dir /srv/shiny/-server/apps;
  }
  ...
}
</code></pre>
<p>上面的命令将定义两个路径，一个服务URL/OtherApps/下的多个应用程序，另外一个服务URL/specialApp/下的单个应用程序。<br />
在<a href="http://docs.rstudio.com/shiny-server/#hosting-model">host模式</a>部分有介绍各种托管模式.</p>
<p><strong>Location</strong> 还可以嵌套位置指令,提供特<strong>sub-locarion</strong>.例如，如果您使用Google Analytics，但是财务部门希望使用自己的Google Analytics ID作为其财务目录，那么可以通过以下配置来完成此任务：</p>
<pre><code>server {
  ...
  # Define the &#39;/depts&#39; location
  location /depts {
    # Host a directory of applications
    site_dir /srv/departmentApps;
    
    # Provide a default/global GAID
    google_analytics_id &quot;UA-12345-1&quot;;

    # Define the &#39;/finance&#39; location.
    # Corresponds to the URL &#39;/depts/finance&#39;, and the filesystem path 
    # &#39;/srv/departmentApps/finance&#39; as defined by the parent location.
    location /finance {
      # Provide a custom GAID for only this sub-location
      google_analytics_id &quot;UA-54321-9&quot;;
    }
  }
  ...   
</code></pre>
</div>
</div>
<div id="run_as" class="section level2">
<h2>2.3 run_as</h2>
<p>知道哪个用户在执行R shiny进程非常重要，例如，不同的用户有不同的R搜索包的路径<code>(.libPaths())</code> 。<br />
<strong>location</strong>配置中：<br />
- user_apps模式：配置应用程序执行的位置<br />
- site_dir, user_dirs和app_dir模式：配置应用程序所在的位置<br />
- run_as模式：配置执行shiny应用程序的用户</p>
<p>可以在全局环境或者特定server或location下配置。例如：</p>
<pre><code>location / {

  run_as tim;

}   
</code></pre>
<p>以tim身份执行包含在该范围内的所有应用程序，tim相关的<code>.libPaths</code></p>
<p>Bash shell 加载配置信息顺序
- 1 /etc/profile
在读取该文件之后，它查找下列文件，并读取并执行来自第一个文件并且是可读的命令（需要注意的是，这些文件中只有一个文件将被读取和执行）：<br />
- 2 ~/.bash_profile<br />
- 2 ~/.bash_login<br />
- 2 ~/.profile</p>
<p>对于上面的示例设置，当运行shiny server 的配置使用者为tim，那么在/etc/profile中或者/home/tim/.bash_profile（假定tim的主目录在标准的location）中的任何环境变量都能被R进程使用。</p>
<div id="home_user" class="section level3">
<h3>2.3.1 :HOME_USER:</h3>
<p><strong>:HOME_USER:</strong>是run_as使用的特例。当与user_dirs托管模式（在<a href="http://docs.rstudio.com/shiny-server/#host-per-user-application-directories">Host Per-User Application Directories</a>的部分中描述）组合使用时，此设置将Shiny Server将在用户主目录中运行该进程。例如，位于目录/home/jim/ShinyApps/app1下的应用程序，将以jim用户运行，位于目录/home/kelly/ShinyApps/app1下的应用程序将以kelly用户运行。</p>
<pre><code>run_as :HOME_USER: shiny;

...

location /users {

  user_dirs;

}

location /apps {

  site_dir /srv/shiny-server;
  log_dir /var/log/shiny-server;
  directory_index on;

}

</code></pre>
<p>所有托管在<strong>/users</strong>目录下的<strong>user_dirs</strong>应用程序将会以<strong>:HOME_USER:</strong>（应用程序存在于其主目录中的用户），因为这是最高优先级run_as用户。因为<strong>:HOME_USER:</strong>只有在<strong>user_dirs</strong>托管模式下才有意义，而在<strong>site_dir</strong>模式下是没有意义的，托管在/apps中的应用程序不会以<strong>:HOME_USER:</strong>运行，而是按后面的用户运行——在本例中，作为shiny。</p>
<p>也可以使用下面的配置达到同样的效果：</p>
<pre><code>location /users {
  run_as :HOME_USER: ;
  user_dirs;
}

location /apps {
  run_as shiny;
  site_dir /srv/shiny-server;
  log_dir /var/log/shiny-server;
  directory_index on;
}
</code></pre>
<p>如<a href="http://docs.rstudio.com/shiny-server/#host-per-user-application-directories">Host Per-User Application Directories</a>所述，<strong>user_apps</strong>和<strong>user_dirs</strong>仅在关于<strong>run_as</strong>设置上有所不同。<strong>user_apps</strong>将始终设置<strong>run_as</strong>为<strong>:HOME_USER:</strong>托管应用程序，而不管<strong>run_as</strong>实际上是如何设置的。另一方面，<strong>user_dirs</strong>将尊重<strong>run_as</strong>配置。</p>
</div>
<div id="root权限下运行shiny-server服务" class="section level3">
<h3>2.3.2 root权限下运行shiny server服务</h3>
<p>除了生成作为特定用户的R Shiny进程之外，还可以将shiny-server进程本身配置为作为不同用户运行，以控制其特权。在许多情况下，Shiny Server需要作为根用户运行。</p>
<p>默认情况下<strong>shiny-server</strong>进程需要在<strong>root</strong>权限下运行，然后将根据相应的run_as设置生成R进程。但是，如果没有违反上述任何限制，您可以作为非特权用户（如shiny用户）运行shiny-server进程。</p>
<p>默认情况下，如果shiny-server检测到它不需要以根权限运行，它将尝试以非特权用户的身份运行，以便更安全。它将通过检查配置文件中的run_as指令来确定运行哪个用户——如果在run_as语句中只定义了一个用户，并且满足上述约束，则整个Shiny Server进程将作为该用户运行。默认配置将run_as设置为shiny，因此进程将作为shiny用户运行。注意，虽然流程将作为定义的用户运行，但是它的行为方式可能与该用户的交互式登录完全不同。特别地，不会为用户设置补充组。</p>
<p>请注意，在安装Shiny Server时，设置了文件系统的权限，以使闪烁用户能够根据需要从各种目录读取和写入，以允许Shiny Server作为闪烁用户运行。作为另一个用户运行Shiny Server将需要调整权限，以授予这个其他用户运行Shiny Server所必需的特权。特别地，确保用户在这些路径上（递归地）具有写权限：</p>
<ul>
<li>/var/lib/shiny-server/ （或者 自定义的SHINY_DATA_DIR设置）<br />
</li>
<li>/var/log/shiny-server/ （和/或者 其他任何log存放文件夹）</li>
</ul>
<p>在这些路径上（递归地）具有读权限：</p>
<ul>
<li>/srv/shiny-server/（和/或者 其他托管Shiny程序的文件夹）<br />
</li>
<li>/opt/shiny-server/<br />
</li>
<li>/etc/shiny-server/（注意，您应该<strong>只</strong>启用此目录上的读访问权限，因为您可能不希望允许Shiny应用程序（也运行为shiny）能够写入配置或密码文件。）</li>
</ul>
<p>最后，如果目录/tmp/shiny-server/存在，则它（及其中的所有文件）应该由您指定的用户拥有。</p>
</div>
</div>
<div id="本地应用程序配置" class="section level2">
<h2>2.6 本地应用程序配置</h2>
<p>在全局配置文件中，可以通过<strong>allow_app_override</strong>来设置启用本地应用程序配置。此设置使Shiny应用程序的所有者能够使用名为<strong>.shiny_app.conf</strong>的文件自定义自己的应用程序的配置文件。该文件可以放在应用程序目录中（与server.R和ui.R文件一起），并且可以包含配置Shiny Server应该如何管理应用程序的设置。默认<strong>allow_app_override</strong>的设置为disabled的。可以将<strong>allow_app_override true; </strong>或者（简写为<strong>allow_app_override;</strong>）添加到本地配置文件中。</p>
</div>
<div id="托管模式hosting-model" class="section level2">
<h2>2.7 托管模式（Hosting Model）</h2>
<p>目前有四种配置location的不同方法，其中三种用于Shiny应用程序（接下来介绍）。
第四种模式在<a href="http://docs.rstudio.com/shiny-server/#redirecting"><strong>Redirecting</strong></a>部分介绍.</p>
<div id="托管包含多个应用程序的文件夹" class="section level3">
<h3>2.7.1 托管包含多个应用程序的文件夹</h3>
<p>location下指定site_dir将会托管完整的目录树–同时包含应用程序和静态资源。用于在Shiny Server的默认配置文件中/srv/shiny-server/中提供静态资源或应用程序的位置：</p>
<pre><code># Define the location &#39;/&#39;
location / {
  site_dir /srv/shiny-server/
}
</code></pre>
<p>上面的配置使/srv/shiny-server/目录在根目录URL(/)处可用。在这个目录或者子目录中的应用程序，以及所有静态资源（包括images，data，JavaScript/CSS 等文件），均可以通过URL访问。例如，如下目录结构：</p>
<pre><code>+---/srv/shiny-server
|   +---shinyApp1
|       +---server.R
|       +---ui.R
|   +---shinyApp2
|       +---server.R
|       +---ui.R
|   +---assets
|       +---style.css
|       +---script.js
</code></pre>
<hr />
<table>
<thead>
<tr class="header">
<th>URL</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="http://server.com/shinyApp1" class="uri">http://server.com/shinyApp1</a></td>
<td>Serve the Shiny App defined in ‘shinyApp1’</td>
</tr>
<tr class="even">
<td><a href="http://server.com/shinyApp2" class="uri">http://server.com/shinyApp2</a></td>
<td>Serve the Shiny App defined in ‘shinyApp2’</td>
</tr>
<tr class="odd">
<td><a href="http://server.com/assets/style.css" class="uri">http://server.com/assets/style.css</a></td>
<td>Serve this static CSS file</td>
</tr>
<tr class="even">
<td><a href="http://server.com/assets/script.js" class="uri">http://server.com/assets/script.js</a></td>
<td>Serve this static JS file</td>
</tr>
</tbody>
</table>
</div>
<div id="托管单个应用程序" class="section level3">
<h3>2.7.2 托管单个应用程序</h3>
<pre><code>
# Define the location &#39;/specialApp&#39;
location /specialApp {
  app_dir /srv/shiny-server/myApp;
}

</code></pre>
<p>配置<strong>location</strong> 负责URL<strong>/specialApp</strong>的使用<strong>app_dir</strong>模式的路由，它服务于存储在目录<strong>/srv/shiny-server/myApp</strong>中的单个应用程序。配置完成后，如果目录<strong>/srv/shiny-server/myApp</strong>中同时存在<strong>server.R</strong>和<strong>ui.R</strong>，可以通过URL <strong><a href="http://server.com/specialApp" class="uri">http://server.com/specialApp</a></strong>。</p>
</div>
<div id="按每个用户托管应用程序文件夹" class="section level3">
<h3>2.7.3 按每个用户托管应用程序文件夹</h3>
<p>location下配置为user_dirs模式，将允许系统上的用户创建和管理他们自己的Shiny应用程序，并在其主目录中提供它们。这个指令将把存储在有权限用户的~/ShinyApps目录中的任何应用程序公开地托管在以用户名前面的URL上。</p>
<p>此权限仅限于使用members_of限制的特定组的用户。例如，以下配置：</p>
<pre><code>
run_as :HOME_USER:;

# Define the root location
location / {
  user_dirs;
  
  # Only allow members of the &#39;shinyUsers&#39; group to host personal applications.
  members_of shinyUsers;
}

</code></pre>
<p>任何在<strong>shinyUsers</strong>组的成员可以托管其目录** ~/ShinyApps<strong>下三任何程序。<br />
例如，用户</strong>tina<strong>，他属于</strong>shinyUsers<strong>组，其家目录为</strong>/home/tina<strong>，目录</strong>/home/tina/ShinyApps/<strong>下有个名为</strong>shinyApp1<strong>的程序，那么这个程序可以通过URL</strong><a href="http://server.com/tina/shinyApp1" class="uri">http://server.com/tina/shinyApp1</a><strong>访问。而</strong> /home/tina/ShinyApps/**目录下的其他应用同样可以以类似的URL访问。</p>
<p><strong>user_dirs</strong>模式的设置最终将覆盖<strong>user_apps</strong>模式下的设置，这两种模式非常相近，不同处在于对<strong>run_as</strong>的设置上，<strong>user_apps</strong>模式会直接忽略<strong>run_as</strong>的设置值，总在其所处的家目录中运行；而<strong>user_dirs</strong>模式接受<strong>run_as</strong>的设置值，可以通过指定<strong>run_as</strong>为<strong>:HOME_USER:</strong>达到<strong>user_apps</strong>模式同样的效果。如下两种配置有相同的效果：</p>
<pre><code>location / {

  user_apps;

}
</code></pre>
<pre><code>location / {
  run_as :HOME_USER: ;
  user_dirs;
}
</code></pre>
<p>注意，虽然Shiny Server支持作为单个用户在user_dirs中运行的能力，但这可能需要做一些调整以使其在服务器上正确运行。例如，以下配置：</p>
<pre><code>location / {
  run_as shiny;
  user_dirs;
}
</code></pre>
</div>
</div>
<div id="重定向" class="section level2">
<h2>2.8 重定向</h2>
<p>location模式中的redirect可以重定向到另外一个URL上。这些locations能立即发送一个响应到客户端，告知其需要重定向的URL。通常，使用<strong>301</strong>状态码作为永久重定向，<strong>302</strong>状态码作为临时重定向。<br />
配置redirect的最后一个选项（<code>TRUE/FLASE</code>）表示，是否应该使用精确匹配。如果重定向被配置为使用精确匹配，则仅重定向精确URL匹配的请求。如果不使用精确匹配，则对该URL路径或该URL的任何子路径的任何请求都将被重定向。例如，</p>
<pre><code># Define a location at the base URL of this &#39;server&#39;
location / {
  # Redirect traffic from &#39;/shinyApp1/&#39; to &#39;http://server.com&#39; temporarily.
  location /shinyApp1 {
    redirect &quot;http://server.com&quot; 302 true;
  }
}
</code></pre>
<p>任何精确匹配<strong>/shinyApp1</strong>路径的请求都会临时重定向到<strong><a href="http://server.com" class="uri">http://server.com</a></strong>。</p>
</div>
<div id="虚拟主机-virtual-hosts" class="section level2">
<h2>2.9 虚拟主机 Virtual Hosts</h2>
<pre><code>server {
  # Instruct this server to listen on port 80
  listen 80;
  
  # Only accept requests for the hostname &#39;server1.com&#39;
  server_name server1.com;
  
  # Define the location for this server.
  location / {
    site_dir /srv/shiny-server1;
    log_dir /var/log/shiny-server1;
  }
}

server {
  # Instruct this server to listen on port 80
  listen 80;
  
  # Only accept requests for the hostname &#39;server2.com&#39;
  server_name server2.com;
  
  # Define the location for this server.
  location / {
    site_dir /srv/shiny-server2;
    log_dir /var/log/shiny-server2;
  }
}
</code></pre>
<p>本示例假定，在这个网络上，域名<strong>server1.com</strong>和<strong>server2.com</strong>都解析为相同的IP地址。在上面的配置中，我们首先创建一个服务器，该服务器在端口<strong>80</strong>上侦听，并且只接受主机名与<strong>server1.com</strong>匹配的通信量。然后，我们配置第二个服务器，它也监听端口<strong>80</strong>，并要求它只接受主机名等于<strong>server2.com</strong>的通信。</p>
<p>在这个配置下，位于<strong>/srv/shiny-server1/shinyApp</strong>的程序能通过http://server1.com/shinyApp访问，而位于 <strong>/srv/shiny-server2/shinyApp</strong> 的程序能通过 <a href="http://server2.com/shinyApp访问" class="uri">http://server2.com/shinyApp访问</a>。</p>
</div>
<div id="自定义模板" class="section level2">
<h2>2.10 自定义模板</h2>
<p>Shiny Server在生成静态页面（如目录索引和错误页面）时可以使用自定义模板。使用<strong>template_dir</strong>指令进行控制，并且可以应用于全局，或者应用于特定的服务器或位置。</p>
<p>为了利用该特性，需要一个专用目录来存储模板；在本例中，我们假设<strong>/etc/shiny-server/templates/</strong>为模板文件夹.在这个目录中，放置网页的页面能启用句柄的HTML模板。</p>
<p>当请求静态页面时，Shiny Server将尝试使用适当的模板进行响应。例如，如果遇到404错误，它将首先查看指定目录中是否提供了用于处理的404错误的特定模板（<strong>error-404.html</strong>）。如果找不到此文件，它将查找通用错误模板（<strong>error.html</strong>）。如果在模板目录中没找到合适的模板，那么它将依赖于Shiny Server（存储在<strong>/opt/shiny-server/templates</strong>中）提供的默认模板。</p>
<p>在命名模板时，必须符合Shiny Server用于文件名的特定连字符分隔模式。所有错误页都以<strong>error</strong>开头，但是404错误页的文件名会在连字符之后添加一个附加的元素（404）: <strong>error-404</strong>。所有文件都需使用.html扩展名。</p>
<table>
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead>
<tr class="header">
<th>Template Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>error-403</td>
<td>Client is forbidden from accessing this page. Or, in Shiny Server Pro, that the user is signed in but does not have permissions to view this application.</td>
</tr>
<tr class="even">
<td>error-404</td>
<td>Page not found</td>
</tr>
<tr class="odd">
<td>error-500</td>
<td>General server error</td>
</tr>
<tr class="even">
<td>error-503-user</td>
<td>The application has exceeded its maximum # of users</td>
</tr>
<tr class="odd">
<td>error-503-license</td>
<td>(Pro Only) You have exceeded the number of concurrent users allotted for your license.</td>
</tr>
<tr class="even">
<td>directoryIndex</td>
<td>Shown when directory_index is enabled for a location and the user visits the base URL.</td>
</tr>
<tr class="odd">
<td>login</td>
<td>(Pro Only) Used to render the login page.</td>
</tr>
</tbody>
</table>
<p>例如，一个名为error-503.html的文件可以用作error-503-users页面以及error-503-license页面的模板。一般地，可以通过将单个模板命名为error.html.如果不存在更具体的模板，则在为任何类型的错误生成页面时将使用此页面。</p>
<p>建议修改已有的模板，创建自己的模板。将相关的HTML文件从<strong>/opt/shiny-server/templates/</strong>复制到模板目录（例如<strong>/etc/shiny-server/templates/</strong>）。例如，为了创建自定义错误页，执行：</p>
<pre><code>mikdir /etc/shiny-server/templates/
cp /opt/shiny-server/templates/error.html /etc/shiny-server/templates/
</code></pre>
<p>现在在首选文本编辑器中打开新模板并修改它。最初，保持整个结构不变，但是在页面顶部（紧挨着包含<code>&lt;h1&gt;{title}}&lt;/h1&gt;</code>）添加一些语言，或者添加一些新的CSS规则，并保存文件。</p>
<p>将下面的命令添加到配置文件的顶部/底部，应用于全局，利用新的模板搭建shiny server服务：</p>
<pre><code>template_dir /etc/shiny-server/templates;   </code></pre>
<p>重新启动服务器并访问错误页面时，所加载的页面上看到新文本或CSS样式。（尝试访问隐藏文件，如 <a href="http://server.com:3838/.hidden" class="uri">http://server.com:3838/.hidden</a> ，其中<strong>server.com</strong>是服务器的域名或IP地址，应该使用error-403或error模板。）同样，可以将<strong>directoryIndex.html</strong>模板复制到自定义目录并开始定制模板。</p>
<p>出于性能原因，模板一旦加载了，则缓存在内存中。因此，在刷新页面时，会发现对模板的更改可能不会立即生效。可以通过重新启动或重新加载服务器（参见<a href="http://docs.rstudio.com/shiny-server/#stopping-and-starting">服务停止和启动</a>部分）清空缓存并强制Shiny Server加载更改的新模板。</p>
<p>最后，请注意，这些模板目前仅适用于Shiny Server生成的HTML页面。Shiny包生成的HTML页面此时将不应用自定义模板。目前，最明显的是404错误。如果访问Shiny Server不能直接指向Shiny应用程序的URL（例如，<a href="http://server.com:3838/flargdarg，其中server.com是服务器的域名或IP地址" class="uri">http://server.com:3838/flargdarg，其中server.com是服务器的域名或IP地址</a>），将看到Shiny-Server生成的404错误页面，其中应用了定制模板（假设此<strong>server</strong>配置过自定义error-404.HTML或Error .HTML模板）。但是，如果访问的是有效应用程序中不存在的文件，则会看到未样式化的404页，该页没有利用自定义模板。例如，如果一个应用程序部署在<strong><a href="http://server.com:3838/myApp" class="uri">http://server.com:3838/myApp</a></strong>，并且试图访问<strong><a href="http://server.com:3838/myApp/flargdarg" class="uri">http://server.com:3838/myApp/flargdarg</a></strong>，请求将被发送到Shiny，然后Shiny查找该文件，如果没有找到，将返回404页。Shiny Server会将此响应直接传递回客户端，因为它不是由Shiny Server生成的。</p>
</div>
<div id="shiny-server服务日志" class="section level2">
<h2>2.12 shiny-server服务日志</h2>
<p>所有与Shiny Server本身相关的信息，而不是特定的Shiny应用程序，都记录在全局系统日志/var/log/shiny-server.log中。应该经常检查此日志以确保Shiny Server按预期执行。Shiny Server需要传达的任何错误和警告都写在这个文件中。</p>
<p>如果安装Shiny Server时<strong>logrotate</strong>可用，则将安装<strong>logrotate</strong>配置。默认配置是当日志文件的大小超过1MB时转换该文件。旧的日志文件将被压缩在扩展名为.1.gz（以及.2.gz等）格式的文件，并存储原始日志文件旁边。最多存在12个归档的日志文件；转换第13个日志文件时，将会删除最旧的日志文件。</p>
<p>有关Shiny应用程序的日志，请参阅<a href="http://docs.rstudio.com/shiny-server/#logging-and-analytics">日志记录和分析</a>部分。</p>
<div id="access-logs" class="section level3">
<h3>2.12.1 Access Logs</h3>
<p>使用<strong>access_log</strong>配置访问日志文件的全局参数，默认是没有记录访问日志的，这个设置能控制访问日志的位置和文件格式。访问日志可用于监视Shiny Server上发生的安全性和活动。可以对这些日志进行手动或自动监视，以检查各种资源被访问的频率，或者由谁（使用原始IP地址）访问它们。目前，整个Shiny Server进程创建一个访问日志，所有Shiny应用程序都共享这个访问日志。</p>
<p>访问日志将使用 <a href="https://github.com/expressjs/morgan">morgan</a>日志库编写；更多细节可以在文档的<a href="https://github.com/expressjs/morgan#predefined-formats">Formats</a>部分找到。简言之，对于在上面引用的文档中指定的访问日志，有五种预定义的日志格式：<br />
- <strong>combined</strong> ‘:remote-addr - - [:date] “:method :url HTTP/:http-version” :status :res[content-length] “:referrer” “:user-agent”’<br />
- <strong>common</strong> ‘:remote-addr - - [:date] “:method :url HTTP/:http-version” :status :res[content-length]’
- <strong>short</strong> ‘:remote-addr - :method :url HTTP/:http-version :status :res[content-length] - :response-time ms’
- <strong>tiny</strong> ‘:method :url :status :res[content-length] - :response-time ms’
- <strong>dev</strong> 用于开发，有颜色的简单输出</p>
<p>例如，如下代码将会配置一个<strong>tiny</strong>格式的访问日志：</p>
<pre><code>access_log /var/log/shiny-server/access.log tiny;

server {
  ...
</code></pre>
</div>
</div>
<div id="设定环境变量" class="section level2">
<h2>2.13 设定环境变量</h2>
<p>通常，最好在运行Shiny Server的启动脚本中定义这些环境变量。这取决于您正在运行的Linux发行版和版本。</p>
<div id="systemdredhat-7-ubuntu-15.05-sles-12" class="section level4">
<h4>2.13.0.1 systemd(RedHat 7, Ubuntu 15.05+, SLES 12+)</h4>
<p>修改文件<code>/etc/systemd/system/shiny-server.service</code></p>
<p>定义环境变量：</p>
<pre><code>[Service]
Environment=&quot;SHINY_LOG_LEVEL=TRACE&quot;</code></pre>
<p>修改后，运行下面命令使配置生效：</p>
<pre><code>sudo systemctl stop shiny-server
sudo systemctl daemon-reload
sudo systemctl start shiny-server
</code></pre>
</div>
<div id="upstartubuntu-12.04-through-14.10-and-redhat-6" class="section level4">
<h4>2.13.0.2 Upstart(Ubuntu 12.04 through 14.10 and RedHat 6)</h4>
<p>修改文件<code>/etc/init/shiny-server.conf</code></p>
<p>定义环境变量：</p>
<pre><code>env SHINY_LOG_LEVEL=TRACE</code></pre>
<p>修改后，运行下面命令使配置生效：</p>
<pre><code>sudo stop shiny-server
sudo start shiny-server</code></pre>
</div>
<div id="init.dredhat-5-sles-11" class="section level4">
<h4>2.13.0.3 init.d(RedHat 5, SLES 11)</h4>
<p>修改文件<code>/etc/init.d/shiny-server</code></p>
<p>定义环境变量：</p>
<pre><code>export SHINY_LOG_LEVEL=TRACE</code></pre>
<p>修改后，运行下面命令使配置生效：</p>
<pre><code>sudo /sbin/service shiny-server restart </code></pre>
</div>
<div id="shiny_log_level" class="section level3">
<h3>2.13.1 SHINY_LOG_LEVEL</h3>
<p>可选参数：<strong>TRACE</strong>、<strong>DEBUG</strong>、<strong>INFO</strong>（默认情况）、<strong>WARN</strong>、<strong>ERROR</strong>。</p>
</div>
<div id="r" class="section level3">
<h3>2.13.2 R</h3>
<p>定义当Shiny运行时R可执行文件的路径。安装了多个版本R的系统，或者在启动ShinyServer之前的路径上没有R，可以使用此设置指向特定版本R。注意，对于配置文件中具有已[r_path]的配置，此环境变量将不生效。如果没有找到环境变量，Shiny Server将预期此路径上会出现一个名为R的可执行文件。</p>
</div>
</div>
</div>
<div id="部署应用程序" class="section level1">
<h1>3 部署应用程序</h1>
<div id="任务调度-应用重启" class="section level2">
<h2>3.1 任务调度 &amp; 应用重启</h2>
<p>调度程序负责处理应用程序的传入请求。应用程序的每个版本（见下文）都有自己的相关调度程序。每个调度程序可以具有不同的属性来控制它应该接受多少并发连接。</p>
</div>
<div id="重新启动应用程序" class="section level2">
<h2>3.1.1 重新启动应用程序</h2>
<p>在修改shiny程序的代码、静态资源、或者环境变量后，需要重新启动shiny程序的R进程使其生效。这些包括对应用程序使用的包的升级，对<strong>.Renviron/.Rprofile</strong>或者其他R文件或者对启动时只读的数据文件的修改。</p>
<p>幸运的是，在对ui.R或server.R进行更改时，Shiny应用程序通常不需要重新启动，因为Shiny会在页面加载时检查这些文件的更改。</p>
<p>可以通过更改应用程序目录中名为restart.txt的文件的“修改时间”来重新启动应用程序。使用touch实用程序可以非常容易地完成此操作，如在touch restart.txt中，它将更新该文件上修改的时间戳到当前时间。</p>
<div id="simple-scheduler" class="section level3">
<h3>3.1.2 Simple Scheduler</h3>
<p>Simple Scheduler是Shiny Server的开源版本中唯一可用的调度器。它将单个R进程与一个shiny应用程序关联起来。此调度程序接受一个参数，该参数指定并发会话的最大数量。一旦达到这个数字，试图在这个应用程序上创建新会话的用户将收到一个503错误页面。</p>
<pre><code># Define a new location at the base URL
location / {
  # Define the scheduler to use for this location
  simple_scheduler 15;
  
  ...
}   </code></pre>
</div>
</div>
<div id="r-markdown" class="section level2">
<h2>3.2 R Markdown</h2>
<p>除了从目录（服务器.R文件和相关联的UI）提供传统的Shiny应用程序之外，Shiny Server现在还支持交互的R Markdown文档。</p>
<pre><code>sudo su --c &quot;R -e \&quot;install.packages(&#39;rmarkdown&#39;)\&quot;&quot;</code></pre>
<p>如果托管目录不包括server.R文件，Shiny Server将查看它是否包含任何.Rmd文件。如果有，Shiny Server将使用rmarkdown::run在“R Markdown”模式下托管该目录。</p>
<p>可以通过引用包括文件名的完整路径来访问特定的Rmd文件，例如，<a href="http://myserver.org/mydocs/hello.Rmd。如果向目录而不是特定的Rmd文件发出请求，Shiny" class="uri">http://myserver.org/mydocs/hello.Rmd。如果向目录而不是特定的Rmd文件发出请求，Shiny</a> Server将尝试提供文件index.Rmd。如果该文件不存在，则用户将得到一个错误，警告他们该文件不可用。</p>
</div>
<div id="应用程序超时" class="section level2">
<h2>3.3 应用程序超时</h2>
<p>每个shiny的应用程序都有两个超时时间：</p>
<p><strong>app_init_timeout</strong> –描述等待应用程序启动的时间（以秒为单位）。在指定的秒数过去之后，如果R进程仍然没有响应，则认为启动不成功，连接将关闭。 app_init_timeout的默认值为60秒。<br />
<strong>app_idle_timeout</strong> –定义没有活动连接的R进程应该保持打开的时间（以秒为单位）。在最后一个连接从R进程断开之后，这个计时器将启动，并且在指定的秒数之后，如果没有创建新的连接，则R进程将被终止。app_idle_timeout的默认值为5秒。</p>
<p>通常，这两个参数将是相关的。启动时只需要很少的处理（因此具有小的app_init_timeout）的shiny应用程序通常可以以最少的关注来关闭（因此将具有小的app_idle_timeout）。相反，在启动时需要加载大量数据的应用程序可能需要较长的app_init_timeout来给数据加载时间，并且由于生成新进程的任务比较昂贵，因此较长的app_idle_timeout应该被最小化。</p>
</div>
<div id="日志记录与分析" class="section level2">
<h2>3.5 日志记录与分析</h2>
<div id="应用程序错误日志" class="section level3">
<h3>3.5.1 应用程序错误日志</h3>
<p>每个R shiny进程都会生成一个自己error日志。若location配置为<strong>user_apps or user_dirs</strong>，日志文件将在用户的<strong>~/ShinyApps/log/</strong>目录下，若location配置为<strong>app_dir or site_dir</strong>，则需要使用<strong>log_dir</strong>设置日志存放的文件夹，可以为全局、特定服务器或特定位置设定。默认情况下，日志文件存放在<strong>/var/log/shiny-server/</strong>下。在<strong>location</strong>层级下，使用<strong>log_dir</strong>可以指定特定的文件夹来存放日志文件。</p>
<pre><code>location /{
  log_dir /var/log/shiny-server/; 
}</code></pre>
<p>生成日志文件的命名格式：<code>&lt;application directory name&gt;-YYYMMDD-HHmmss-&lt;port number or socket ID&gt;.log</code></p>
<p>每个R进程启动的时候会生成一个日志文件。但是当一个进程正常终止后，这个进程的错误日志文件将会自动删除。将保留在磁盘上的唯一错误日志文件是与未按预期退出R进程相关联的错误日志文件。</p>
<p>可以配置<strong>preserve_logs</strong>来修改这个过程，若<strong>preserve_logs true</strong>则在进程结束后不会删除日志文件。<strong>注意</strong>这个设置可能会导致日志文件在繁忙的服务器上快速积累。此设置<strong>仅建议用于调试目的</strong>；如果要在生产服务器上启用它，则需要密切注意日志的旋转和归档，以防止文件系统被日志文件淹没。</p>
<p>如果查找与Shiny Server本身相关的日志消息，而不是单个Shiny应用程序，请参阅<a href="http://docs.rstudio.com/shiny-server/#server-log">服务器日志</a>部分。</p>
</div>
<div id="日志文件的权限" class="section level3">
<h3>3.5.2 日志文件的权限</h3>
<p>默认情况下，使用模式<strong>0640</strong>创建应用程序日志文件，模式<strong>0640</strong>禁止shiny和root之外的用户访问它们。</p>
<p>默认的日志文件模式可以使用<strong>log_file_mode</strong>指令进行定制，与<strong>log_dir</strong>一样，<strong>log_file_mode</strong>指令可以在全局、特定服务器或特定位置指定。为了在location级别修改日志可见性，使系统上的所有用户可以访问日志，可以按照以下方式指定<strong>log_file_mode</strong>：</p>
<pre><code>location /{
  log_file_mode 0644;    #注意，log_file_mode值必须以零开始，因为它是八进制数。
}</code></pre>
</div>
<div id="google-analytics" class="section level3">
<h3>3.5.3 Google Analytics</h3>
<p>Shiny Server能够自动插入必要的JavaScript代码，以启用<strong>Google Analytics</strong>的全局跟踪，或者针对特定的服务器或位置进行跟踪。可以通过<strong>google_analytics_id</strong>设置。</p>
<pre><code>location / {
  google_analytics_id UA-12345-1;
}</code></pre>
</div>
</div>
<div id="reactivity-log" class="section level2">
<h2>3.7 Reactivity Log</h2>
</div>
<div id="指定协议-specifying-protocols" class="section level2">
<h2>3.8 指定协议 Specifying Protocols</h2>
</div>
<div id="点击保护-clickjacking-protection" class="section level2">
<h2>4.11 点击保护 Clickjacking Protection</h2>
<pre><code>frame_options deny;
server {
  listen 3838;

  ...

}
</code></pre>
</div>
</div>
<div id="附录" class="section level1">
<h1>7 附录</h1>
<div id="快速启动" class="section level2">
<h2>7.1 快速启动</h2>
<p>我们建议阅读本指南的各部分，以全面了解如何操作Shiny Server。但是如果只是想快速地启动，那么可以按照下面的指南设置。<br />
所有这些指南将帮助您定制存储在<strong>/etc/shiny-server/shiny-server.conf</strong>中的Shiny Server配置文件。</p>
<ul>
<li><strong><a href="http://docs.rstudio.com/shiny-server/#host-a-directory-of-applications-1">托管整个文件夹下面多个apps</a></strong> - 本地配置文件<strong>/etc/shiny-server/shiny-server.conf</strong>,如何托管<strong>/srv/shiny-server/</strong>。<br />
</li>
<li><strong><a href="http://docs.rstudio.com/shiny-server/#let-users-manage-their-own-applications">让用户管理他们自己的应用程序</a></strong> - 用户创建并存储在其主目录中的Shiny应用程序提供服务。<br />
</li>
<li><strong><a href="http://docs.rstudio.com/shiny-server/#run-shiny-server-on-multiple-ports">在多个端口上运行Shiny服务器</a></strong> - 本指南将介绍多服务器配置，它演示如何在服务器的不同端口上运行两个不同的服务。它还配置一个具有多个位置的服务器。</li>
</ul>
<div id="托管整个文件夹下面多个apps" class="section level3">
<h3>7.1.1 托管整个文件夹下面多个apps</h3>
<p>Shiny Server的配置文件是<strong>/etc/shiny-server/shiny-server.conf</strong>，作为“快速启动”指南，我们在<strong>/opt/shiny-server/bin/deploy-example</strong>中提供了一个方便的可执行文件，可以将与此快速启动关联的示例配置文件复制到该位置，并安装示例应用程序的目录。<strong>请确保首先备份当前配置文件</strong>，然后运行以下命令：</p>
<pre><code>sudo /opt/shiny-server/bin/deploy-example default</code></pre>
<p>此配置要求Shiny应用程序托管在<strong>/srv/shiny-server/</strong>下，安装程序还将在<strong>/srv/shiny-server/sample-apps/hello/</strong>中放置一个示例应用程序。<br />
默认情况下，Shiny Server侦听端口3838，因此可以通过URL<strong><a href="http://" class="uri">http://</a><server-address>:3838/sample-apps/hello/</strong>访问这个程序。若在本地运行URL<strong><a href="http://127.0.0.1:3838/sample-apps/hello/" class="uri">http://127.0.0.1:3838/sample-apps/hello/</a></strong></p>
<p>可以修改<strong>/etc/shiny-server/shiny-server.conf</strong>配置文件的设置，<strong>listen 3838</strong>为<strong>listen 12345</strong>。然后重启server生效。</p>
<p>现在，如果您使用的发行版支持Upstart（最近的发行版，包括Ubuntu 12和稍后的发行版以及CentOS 6），则将运行此命令：<code>sudo restart shiny-server</code></p>
<p>如果您使用的是依赖init.d（例如CentOS 5）的旧系统，则将运行以下命令：<code>sudo /sbin/service shiny-server restart</code></p>
<p>或者运行<code>sudo systemctl restart shiny-server</code></p>
</div>
<div id="托管单个应用程序-1" class="section level3">
<h3>7.1.2 托管单个应用程序</h3>
<ul>
<li>修改<strong>/etc/shiny-server/shiny-server.conf</strong></li>
</ul>
<pre><code>
# Tell Shiny Server that we want to run as the user whose 
# home directory we find the application in.
run_as :HOME_USER:;

# Define a server that listens of port 3838.
server {
  listen 3838;

  # Define a location at the base URL
  location / {
    
    # Allow users to host their own apps in ~/ShinyApps
    user_dirs;

    # Optionally, you can restrict the privilege of hosting Shiny applications
    # only to members of a particular Linux group.
    # members_of shinyUsers;
  }
}
</code></pre>
</div>
</div>
</div>
